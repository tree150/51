C51 COMPILER V9.54   UART                                                                  11/17/2025 21:07:18 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\UART.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE UART.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\UART.ls
                    -t) TABS(2) OBJECT(.\Objects\UART.obj)

line level    source

   1          #include <STC89C5xRC.H>
   2          #include "UART.h"
   3          #include "Delay.h"
   4          
   5          // 全局变量定义
   6          char uart_receive_buffer[64] = {0};    // 增大缓冲区
   7          unsigned char uart_buffer_index = 0;
   8          bit uart_data_ready = 0;
   9          
  10          /**
  11            * @brief  串口初始化 - 针对ISP串口助手优化
  12            */
  13          void UART_Init(void)
  14          {
  15   1          // 设置定时器1为8位自动重装模式
  16   1          TMOD &= 0x0F;
  17   1          TMOD |= 0x20;
  18   1          
  19   1          // 设置波特率为9600 @11.0592MHz
  20   1          TH1 = 0xFD;
  21   1          TL1 = 0xFD;
  22   1          
  23   1          // 设置串口模式1，允许接收
  24   1          SCON = 0x50;
  25   1          
  26   1          // 波特率不加倍
  27   1          PCON &= 0x7F;
  28   1          
  29   1          // 启动定时器1
  30   1          TR1 = 1;
  31   1          
  32   1          // 开启串口中断和总中断
  33   1          ES = 1;
  34   1          EA = 1;
  35   1          
  36   1          // 初始化接收缓冲区
  37   1          UART_ClearBuffer();
  38   1      }
  39          
  40          /**
  41            * @brief  发送一个字节
  42            */
  43          void UART_SendByte(unsigned char byte)
  44          {
  45   1          SBUF = byte;
  46   1          while(TI == 0);  // 等待发送完成
  47   1          TI = 0;          // 清除发送标志
  48   1      }
  49          
  50          /**
  51            * @brief  发送字符串 - 针对ISP串口助手优化
  52            */
  53          void UART_SendString(char *str)
  54          {
C51 COMPILER V9.54   UART                                                                  11/17/2025 21:07:18 PAGE 2   

  55   1          while(*str != '\0')
  56   1          {
  57   2              UART_SendByte(*str);
  58   2              str++;
  59   2          }
  60   1          // ISP串口助手需要换行才能正确显示
  61   1          UART_SendByte('\r');
  62   1          UART_SendByte('\n');
  63   1      }
  64          
  65          /**
  66            * @brief  发送数字
  67            */
  68          void UART_SendNumber(unsigned int num)
  69          {
  70   1          unsigned char digits[5];
  71   1          unsigned char i = 0;
  72   1          
  73   1          if(num == 0)
  74   1          {
  75   2              UART_SendByte('0');
  76   2              return;
  77   2          }
  78   1          
  79   1          // 提取各位数字
  80   1          while(num > 0)
  81   1          {
  82   2              digits[i++] = '0' + (num % 10);
  83   2              num /= 10;
  84   2          }
  85   1          
  86   1          // 逆序发送
  87   1          while(i > 0)
  88   1          {
  89   2              UART_SendByte(digits[--i]);
  90   2          }
  91   1      }
  92          
  93          /**
  94            * @brief  接收一个字节（查询方式）
  95            */
  96          unsigned char UART_ReceiveByte(void)
  97          {
  98   1          if(RI == 1)
  99   1          {
 100   2              RI = 0;
 101   2              return SBUF;
 102   2          }
 103   1          return 0;
 104   1      }
 105          
 106          /**
 107            * @brief  检查是否有数据可读
 108            */
 109          bit UART_DataAvailable(void)
 110          {
 111   1          return (RI == 1);
 112   1      }
 113          
 114          /**
 115            * @brief  检查是否有完整的一行数据
 116            */
C51 COMPILER V9.54   UART                                                                  11/17/2025 21:07:18 PAGE 3   

 117          bit UART_HasCompleteLine(void)
 118          {
 119   1          return uart_data_ready;
 120   1      }
 121          
 122          /**
 123            * @brief  清空接收缓冲区
 124            */
 125          void UART_ClearBuffer(void)
 126          {
 127   1          unsigned char i;
 128   1          for(i = 0; i < 64; i++)
 129   1          {
 130   2              uart_receive_buffer[i] = 0;
 131   2          }
 132   1          uart_buffer_index = 0;
 133   1          uart_data_ready = 0;
 134   1      }
 135          
 136          /**
 137            * @brief  获取接收缓冲区指针
 138            */
 139          char* UART_GetBuffer(void)
 140          {
 141   1          return uart_receive_buffer;
 142   1      }
 143          
 144          /**
 145            * @brief  串口中断服务函数 - 针对ISP串口助手优化
 146            */
 147          void UART_Interrupt() interrupt 4
 148          {
 149   1          unsigned char received_char;  // 变量声明必须放在函数开头
 150   1          
 151   1          if(RI == 1)  // 接收中断
 152   1          {
 153   2              RI = 0;
 154   2              received_char = SBUF;  // 赋值操作
 155   2              
 156   2              // 存储接收到的字符
 157   2              if(uart_buffer_index < 63)  // 保留一个位置给结束符
 158   2              {
 159   3                  uart_receive_buffer[uart_buffer_index] = received_char;
 160   3                  uart_buffer_index++;
 161   3                  
 162   3                  // 检测字符串结束符（ISP串口助手通常以回车结束）
 163   3                  if(received_char == '\r' || received_char == '\n')
 164   3                  {
 165   4                      uart_receive_buffer[uart_buffer_index-1] = '\0'; // 替换结束符
 166   4                      uart_data_ready = 1;
 167   4                      uart_buffer_index = 0;
 168   4                  }
 169   3              }
 170   2              else
 171   2              {
 172   3                  // 缓冲区满，强制结束
 173   3                  uart_receive_buffer[63] = '\0';
 174   3                  uart_data_ready = 1;
 175   3                  uart_buffer_index = 0;
 176   3              }
 177   2          }
 178   1          
C51 COMPILER V9.54   UART                                                                  11/17/2025 21:07:18 PAGE 4   

 179   1          if(TI == 1)  // 发送中断
 180   1          {
 181   2              TI = 0;
 182   2          }
 183   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    269    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     65       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
